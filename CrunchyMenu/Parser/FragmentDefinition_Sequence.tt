<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="$(SolutionDir)/bin/CrunchyDough.dll" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Crunchy.Dough" #>
<#@ output extension=".cs" #>
<#
int max_number_fragments = 3;

#>
using System;
using System.Collections;
using System.Collections.Generic;

using Crunchy.Dough;

namespace Crunchy.Menu
{
<#  foreach(bool has_product in new bool[]{false, true}){#> 
<#      for(int number_fragments = 1; number_fragments <= max_number_fragments; number_fragments++){#>
<#
            string base_basic_class_name = "FragmentDefinition" + has_product.ConvertBool("", "Void");
            string base_class_arguments = TTCS.ArgumentsForGeneric("T", has_product);
            string base_class_name = base_basic_class_name + base_class_arguments;
        
            string sub_basic_class_name = base_basic_class_name + "_SubSequence";
            string sub_class_arguments = TTCS.ArgumentsForGeneric("P#", number_fragments, has_product.ConvertBool("T"));
            string sub_class_name = sub_basic_class_name + sub_class_arguments;
        
            string basic_class_name = base_basic_class_name + "_Sequence";
            string class_arguments = TTCS.ArgumentsForGeneric("P#", number_fragments, has_product.ConvertBool("T"));
            string class_name = basic_class_name + class_arguments;
        
            string operation_type = "Operation" + class_arguments;
        
            FragmentEntry[] fragments = Ints.Range(1, number_fragments, 1, true)
                .Convert(i => new FragmentEntry(i))
                .ToArray();
        
            string initialize_parameters = TTCS.Parameters(fragments.Convert(f => f.type_name), "f#", null, has_product.ConvertBool(operation_type + " o"));
            string initialize_arguments = TTCS.Arguments("f#", number_fragments, null, has_product.ConvertBool("o"));
#>

            public class <#=sub_class_name#> : <#=base_class_name#>
            {
<#              if(has_product){#>
                    private <#=operation_type#> producer_operation;            
<#              }#>
    
<#              foreach(FragmentEntry fragment in fragments){#>
                    private <#=fragment.type_name#> <#=fragment.variable_name#>;
<#              }#>

                protected override bool ConsumeInternal(IList<TokenInstance> tokens, int index, out int new_index<#=has_product.ConvertBool(", out Operation<T> producer", "")#>)
                {
                    new_index = index;
                    <#=has_product.ConvertBool("producer = null;", "")#>
                    
<#                   for(int f = 1; f <= number_fragments; f++){#>
                        if(fragment<#=f#>.Consume(tokens, new_index, out new_index, out Operation<P<#=f#>> sub_producer<#=f#>) == false)
                            return false;                        
<#                   }#>
                    
<#                   if(has_product){#>            
                        producer = () => producer_operation(<#=TTCS.Arguments("sub_producer#()", number_fragments)#>);
<#                  }#>            
                    return true;
                }

                public <#=sub_basic_class_name#>()
                {
                }
                
<#              if(has_product){#>
                    public <#=sub_basic_class_name#>(<#=operation_type#> o) : this()
                    {
                        producer_operation = o;
                    }
<#              }#>
                
                public <#=sub_basic_class_name#>(<#=initialize_parameters#>) : this()
                {
                    Initialize(<#=initialize_arguments#>);
                }
                
                public void Initialize(<#=initialize_parameters#>)
                {
<#                  foreach(FragmentEntry fragment in fragments){#>
                        <#=fragment.variable_name#> = <#=fragment.parameter_name#>;
<#                  }#>
            
<#                  if(has_product){#>
                        producer_operation = o;
<#                  }#>
                }
            }
            public class <#=class_name#> : <#=base_class_name#>
            {
                private List<<#=base_class_name#>> sub_sequences;
                
                protected override bool ConsumeInternal(IList<TokenInstance> tokens, int index, out int new_index<#=has_product.ConvertBool(", out Operation<T> producer", "")#>)
                {
                    int best_index = -1;
                    
<#                  if(has_product){#>
                        Operation<T> best_producer = null;
<#                  }#>

                    foreach (<#=base_class_name#> sub_sequence in sub_sequences)
                    {
                        if (sub_sequence.Consume(tokens, index, out new_index<#=has_product.ConvertBool(", out producer", "")#>))
                        {
                            if (new_index >= best_index)
                            {
                                best_index = new_index;
<#                              if(has_product){#>
                                    best_producer = producer;
<#                              }#>
                            }
                        }
                    }

                    if (best_index != -1)
                    {
                        new_index = best_index;
<#                      if(has_product){#>
                            producer = best_producer;
<#                      }#>
                        return true;
                    }

                    new_index = -1;
<#                  if(has_product){#>
                        producer = null;
<#                  }#>
                    return false;
                }

                public <#=basic_class_name#>()
                {
                    sub_sequences = new List<<#=base_class_name#>>();
                }
                
<#              if(has_product){#>
                    public <#=basic_class_name#>(<#=operation_type#> o) : this()
                    {
                        producer_operation = o;
                    }
<#              }#>
                
                public <#=basic_class_name#>(<#=initialize_parameters#>) : this()
                {
                    Initialize(<#=initialize_arguments#>);
                }
                
                public void Initialize(<#=initialize_parameters#>)
                {
                    <#=sub_class_name#> full = new <#=sub_class_name#>(<#=initialize_arguments#>);
                }
            }
            static public partial class FragmentDefinitions
            {
                static public <#=base_class_name#> Sequence<#=class_arguments#>(<#=initialize_parameters#>)
                {
                    return new <#=class_name#>(<#=initialize_arguments#>);
                }
            }
<#      }#>
<#  }#>
}

<#+
class FragmentEntry
{
    public readonly string type_name;
    public readonly string variable_name;
    public readonly string parameter_name;
    
    public FragmentEntry(string t, string v, string p)
    {
        type_name = t;
        variable_name = v;
        parameter_name = p;
    }
    
    public FragmentEntry(int i) : this(
        "FragmentDefinition" + TTCS.ArgumentsForGeneric("P" + i, true),
        "fragment" + i,
        "f" + i
    )
    {
    }
}
#>