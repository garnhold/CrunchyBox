<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
NumericInfo[] types = new NumericInfo[]{
	new NumericInfo("byte", "ByteRange"),
	new NumericInfo("short", "ShortRange"),
	new NumericInfo("int", "IntRange"),
	new NumericInfo("long", "LongRange"),
	new NumericInfo("float", "FloatRange"),
	new NumericInfo("double", "DoubleRange"),
	new NumericInfo("decimal", "DecimalRange")
};
#>
using System;
using System.Collections;
using System.Collections.Generic;

namespace CrunchyDough
{
<# foreach(NumericInfo type in types){#>	
	[Serializable]
    public struct <#=type.class_name#>
	{
		public readonly <#=type.type_name#> x1;
		public readonly <#=type.type_name#> x2;

		public <#=type.class_name#>(<#=type.type_name#> nx1, <#=type.type_name#> nx2)
		{
			x1 = nx1;
			x2 = nx2;
		}

		public override int GetHashCode()
		{
			unchecked
			{
				int hash = 17;

				hash = hash * 23 + x1.GetHashCode();
				hash = hash * 23 + x2.GetHashCode();
				return hash;
			}
		}

		public override bool Equals(object obj)
		{
			<#=type.class_name#> cast;

			if(obj.Convert<<#=type.class_name#>>(out cast))
			{
				if(cast.x1 == x1)
				{
					if(cast.x2 == x2)
						return true;
				}
			}

			return false;
		}

		public override string ToString()
		{
			return "[" + x1 + ", " + x2 + "]";
		}
	}
	static public class <#=type.class_name#>Extensions
	{
		static public <#=type.type_name#> GetWidth(this <#=type.class_name#> item)
		{
			return (<#=type.type_name#>)(item.x2 - item.x1);
		}
	}

<# } #>
}

<#+
public class NumericInfo
{
	public readonly string type_name;
	public readonly string class_name;

	public NumericInfo(string t, string c)
	{
		type_name = t;
		class_name = c;
	}
}
#>